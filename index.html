<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>å¥§å¤šæ¯”ç¢°ç¢°æ¨‚</title>
<style>
    body {
        background: #121214;
        font-family: "Noto Sans TC", sans-serif;
        text-align: center;
        margin: 0;
        padding: 20px;
        color: #f5f5f5;
    }

    h1 {
        margin-bottom: 6px;
    }

    #subtitle {
        font-size: 13px;
        opacity: 0.8;
        margin-bottom: 14px;
    }

    /* éŠæˆ²å¤–æ¡†ï¼ˆç”¨ä¹‹å‰æ²’å•é¡Œçš„å°ºå¯¸ï¼‰ */
    #game-container {
        position: relative;
        width: 310px;
        height: 310px;
        background: #18181c;
        margin: 0 auto;
        border-radius: 16px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.6);
        overflow: hidden;
    }

    /* èƒŒæ™¯ 4x4 æ ¼å­ */
    #grid-layer {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-gap: 10px;
        padding: 10px;
        box-sizing: border-box;
    }

    .grid-cell {
        background: #26262a;
        border-radius: 12px;
    }

    /* ä¸Šé¢çœŸæ­£æœƒå‹•çš„ icon */
    #tile-layer {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 290px;
        height: 290px;
    }

    .tile {
        position: absolute;
        width: 65px;
        height: 65px;
        border-radius: 12px;
        background: #26262a;
        display: flex;
        align-items: center;
        justify-content: center;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        transition: transform 0.12s ease-out;
    }

    .tile.fallback {
        color: #f5f5f5;
        font-weight: bold;
        font-size: 20px;
    }

    .tile.spawn {
        animation: spawn 0.18s ease-out;
    }
    @keyframes spawn {
        from { opacity: 0; }
        to   { opacity: 1; }
    }

    .tile.merge {
        animation: merge 0.22s ease-out;
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
    }
    @keyframes merge {
        0%   { box-shadow: 0 0 0 rgba(255,255,255,0); }
        40%  { box-shadow: 0 0 25px rgba(255,255,255,0.55); }
        100% { box-shadow: 0 0 0 rgba(255,255,255,0); }
    }

    /* ===== åº•éƒ¨æ§åˆ¶å€ ===== */
    #bottom-panel {
        max-width: 310px;
        margin: 14px auto 0;
        text-align: left;
        font-size: 13px;
    }

    .score-row {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
    }

    .score-card {
        flex: 1;
        padding: 6px 10px;
        border-radius: 10px;
        background: #1e1e24;
        box-shadow: 0 4px 10px rgba(0,0,0,0.45);
    }

    .score-label {
        font-size: 11px;
        opacity: 0.75;
        margin-bottom: 2px;
    }

    .score-value {
        font-size: 18px;
        font-weight: 700;
        text-align: right;
    }

    .button-row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
        justify-content: space-between;
    }

    .btn {
        flex: 1;
        border-radius: 999px;
        padding: 6px 10px;
        border: none;
        font-size: 13px;
        cursor: pointer;
        white-space: nowrap;
    }

    .btn-ghost {
        background: #27272f;
        color: #f5f5f5;
    }
    .btn-ghost:hover {
        background: #33333c;
    }

    .btn-primary {
        background: #0a84ff;
        color: #fff;
    }
    .btn-primary:hover {
        background: #3b9bff;
    }

    .hint-row {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        opacity: 0.75;
        margin-top: 4px;
    }

    /* éŠæˆ²çµæŸé®ç½© */
    #game-over-overlay,
    #rank-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .dialog {
        background: #1f1f23;
        padding: 22px 26px;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.65);
        text-align: center;
        min-width: 260px;
        max-width: 320px;
    }

    .dialog h2 {
        margin: 0 0 6px;
        font-size: 20px;
    }

    .dialog p {
        margin: 0 0 14px;
        font-size: 14px;
        opacity: 0.85;
    }

    .game-over-score {
        font-size: 16px;
        margin-bottom: 14px;
    }

    .dialog-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
    }

    .dialog-buttons button,
    .dialog-buttons a {
        border: none;
        outline: none;
        padding: 7px 14px;
        border-radius: 999px;
        font-size: 13px;
        cursor: pointer;
        text-decoration: none;
        transition: background 0.15s ease, transform 0.08s ease;
        white-space: nowrap;
    }

    #btn-upload {
        background: #f15a2a;
        color: #fff;
    }
    #btn-upload:hover {
        background: #ff784c;
        transform: translateY(-1px);
    }

    #btn-play-again {
        background: #2e2e34;
        color: #f5f5f5;
    }
    #btn-play-again:hover {
        background: #3a3a42;
        transform: translateY(-1px);
    }

    #btn-home-overlay {
        background: #45454f;
        color: #f5f5f5;
    }
    #btn-home-overlay:hover {
        background: #575764;
        transform: translateY(-1px);
    }

    /* æ’è¡Œæ¦œè¦–çª— */
    #rank-list {
        text-align: left;
        font-size: 13px;
        max-height: 220px;
        overflow-y: auto;
        margin: 8px 0 0;
        padding-left: 18px;
    }
    #rank-list li {
        margin-bottom: 4px;
    }
    #rank-empty {
        font-size: 13px;
        opacity: 0.8;
    }

    #btn-close-rank {
        margin-top: 14px;
        padding: 6px 16px;
        border-radius: 999px;
        border: none;
        background: #2e2e34;
        color: #f5f5f5;
        cursor: pointer;
        font-size: 13px;
    }
    #btn-close-rank:hover {
        background: #3a3a42;
    }
</style>
</head>
<body>

<h1>å¥§å¤šæ¯”ç¢°ç¢°æ¨‚</h1>
<div id="subtitle">åˆä½µåœ–æ¨™ï¼Œè§£é–å…¨å¥—è»Ÿé«”ï¼</div>

<div id="game-container">
    <div id="grid-layer"></div>
    <div id="tile-layer"></div>
</div>

<!-- åº•éƒ¨æ§åˆ¶å€ -->
<div id="bottom-panel">
    <div class="score-row">
        <div class="score-card">
            <div class="score-label">åˆ†æ•¸</div>
            <div class="score-value" id="score">0</div>
        </div>
        <div class="score-card">
            <div class="score-label">æœ€é«˜åˆ†</div>
            <div class="score-value" id="best-score">0</div>
        </div>
    </div>
    <div class="button-row">
        <button class="btn btn-ghost" id="btn-rank">ğŸ† æ’è¡Œæ¦œ</button>
        <button class="btn btn-ghost" id="btn-sound">ğŸ”ˆ éŸ³æ•ˆï¼šé—œ</button>
        <button class="btn btn-primary" id="btn-restart">ğŸ” é‡æ–°é–‹å§‹</button>
    </div>
    <div class="hint-row">
        <div>æ“ä½œï¼š<b>W A S D</b> æˆ– <b>â†‘ â† â†“ â†’</b></div>
        <div>æ‰‹æ©Ÿå¯ç›´æ¥æ»‘å‹•</div>
    </div>
</div>

<!-- éŠæˆ²çµæŸå½ˆçª— -->
<div id="game-over-overlay">
    <div class="dialog">
        <h2>éŠæˆ²çµæŸ</h2>
        <p>ç›¤é¢å·²ç¶“æ²’æœ‰å¯ä»¥ç§»å‹•çš„æ­¥æ•¸å›‰ï¼</p>
        <div class="game-over-score">æœ¬å±€åˆ†æ•¸ï¼š<span id="final-score-text">0</span></div>
        <div class="dialog-buttons">
            <button id="btn-upload">ä¸Šå‚³æˆç¸¾</button>
            <button id="btn-play-again">å†ç©ä¸€æ¬¡</button>
            <a id="btn-home-overlay" href="#">å›åˆ°é¦–é </a>
        </div>
    </div>
</div>

<!-- æ’è¡Œæ¦œå½ˆçª— -->
<div id="rank-overlay">
    <div class="dialog">
        <h2>å€‹äººæ’è¡Œæ¦œ</h2>
        <p style="margin-bottom:8px;">åªç´€éŒ„ä½ è‡ªå·±ä¸Šå‚³éçš„æœ€ä½³æˆç¸¾ã€‚</p>
        <div id="rank-empty" style="display:none;">ç›®å‰é‚„æ²’æœ‰ä¸Šå‚³ä»»ä½•æˆç¸¾ã€‚</div>
        <ol id="rank-list"></ol>
        <button id="btn-close-rank">é—œé–‰</button>
    </div>
</div>

<script>
    const size = 4;
    const cellSize = 65;
    const cellGap  = 10;

    let board = [];
    let tiles = [];
    let nextId = 1;
    let score = 0;
    let bestScore = 0;
    let isMoving = false;
    let soundOn = false;
    let hasUploadedThisRun = false;

    const SCORE_STORAGE_KEY = 'adobe2048_uploadedScores_v1';

    const iconMap = {
        2:    '1_acrobat.png',
        4:    '2_express.png',
        8:    '3_lightroom.png',
        16:   '4_photoshop.png',
        32:   '5_illustrator.png',
        64:   '6_premiere.png',
        128:  '7_aftereffects.png',
        256:  '8_animate.png',
        512:  '9_firefly.png',
        1024: '10_creativecloud.png'
    };

    const gridLayer      = document.getElementById('grid-layer');
    const tileLayer      = document.getElementById('tile-layer');
    const scoreEl        = document.getElementById('score');
    const bestScoreEl    = document.getElementById('best-score');
    const overlayGameOver = document.getElementById('game-over-overlay');
    const finalScoreText  = document.getElementById('final-score-text');
    const btnUpload       = document.getElementById('btn-upload');
    const btnPlayAgain    = document.getElementById('btn-play-again');
    const btnHomeOverlay  = document.getElementById('btn-home-overlay');

    const overlayRank   = document.getElementById('rank-overlay');
    const rankList      = document.getElementById('rank-list');
    const rankEmpty     = document.getElementById('rank-empty');
    const btnCloseRank  = document.getElementById('btn-close-rank');

    const btnRank       = document.getElementById('btn-rank');
    const btnSound      = document.getElementById('btn-sound');
    const btnRestart    = document.getElementById('btn-restart');

    const tileElements = new Map();

    function buildGrid() {
        for (let i = 0; i < size * size; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            gridLayer.appendChild(cell);
        }
    }

    function loadScoresFromStorage() {
        try {
            const raw = localStorage.getItem(SCORE_STORAGE_KEY);
            if (!raw) return [];
            const arr = JSON.parse(raw);
            if (!Array.isArray(arr)) return [];
            return arr;
        } catch {
            return [];
        }
    }

    function saveScoresToStorage(list) {
        localStorage.setItem(SCORE_STORAGE_KEY, JSON.stringify(list));
    }

    function updateBestScoreFromStorage() {
        const list = loadScoresFromStorage();
        if (list.length === 0) bestScore = 0;
        else bestScore = Math.max(...list.map(item => item.score));
        bestScoreEl.textContent = bestScore;
    }

    function init() {
        overlayGameOver.style.display = 'none';
        hasUploadedThisRun = false;

        board = Array(size).fill(null).map(() => Array(size).fill(null));
        tiles = [];
        nextId = 1;
        score = 0;
        isMoving = false;

        // å›°é›£æ¨¡å¼ï¼šèµ·å§‹ 3 é¡†
        addRandomTile();
        addRandomTile();
        addRandomTile();

        renderAll();
        updateScoreUI();
    }

    function getTileById(id) {
        return tiles.find(t => t.id === id);
    }

    function hasAnyMoves() {
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                if (board[r][c] === null) return true;
            }
        }
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const id = board[r][c];
                const tile = getTileById(id);
                if (!tile) continue;
                const v = tile.value;
                if (c + 1 < size) {
                    const idR = board[r][c+1];
                    if (idR !== null && getTileById(idR).value === v) return true;
                }
                if (r + 1 < size) {
                    const idD = board[r+1][c];
                    if (idD !== null && getTileById(idD).value === v) return true;
                }
            }
        }
        return false;
    }

    function showGameOver() {
        finalScoreText.textContent = score;
        overlayGameOver.style.display = 'flex';
    }

    function updateScoreUI() {
        scoreEl.textContent = score;
        if (score > bestScore) {
            bestScore = score;
            bestScoreEl.textContent = bestScore;
        }
    }

    function addRandomTile() {
        const empty = [];
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                if (board[r][c] === null) empty.push({ r, c });
            }
        }
        if (empty.length === 0) return;
        const { r, c } = empty[Math.floor(Math.random() * empty.length)];

        const roll = Math.random();
        let value;
        if (roll < 0.6)      value = 2;
        else if (roll < 0.9) value = 4;
        else                 value = 8;

        const tile = {
            id: nextId++,
            value,
            row: r,
            col: c,
            isNew: true,
            merged: false,
            toRemove: false
        };
        tiles.push(tile);
        board[r][c] = tile.id;
    }

    function tileTransform(row, col) {
        const x = col * (cellSize + cellGap);
        const y = row * (cellSize + cellGap);
        return `translate(${x}px, ${y}px)`;
    }

    function renderAll() {
        const aliveIds = new Set();

        tiles.forEach(tile => {
            if (tile.toRemove) return;
            aliveIds.add(tile.id);

            let el = tileElements.get(tile.id);
            if (!el) {
                el = document.createElement('div');
                el.className = 'tile';
                tileLayer.appendChild(el);
                tileElements.set(tile.id, el);

                el.addEventListener('animationend', () => {
                    el.classList.remove('spawn');
                    el.classList.remove('merge');
                });
            }

            el.style.transform = tileTransform(tile.row, tile.col);

            const icon = iconMap[tile.value];
            if (icon) {
                el.style.backgroundImage = `url('${icon}')`;
                el.textContent = '';
                el.classList.remove('fallback');
            } else {
                el.style.backgroundImage = 'none';
                el.textContent = tile.value;
                el.classList.add('fallback');
            }

            if (tile.isNew) {
                el.classList.add('spawn');
                tile.isNew = false;
            }
            if (tile.merged) {
                el.classList.add('merge');
                tile.merged = false;
            }
        });

        for (const [id, el] of tileElements.entries()) {
            if (!aliveIds.has(id)) {
                el.remove();
                tileElements.delete(id);
            }
        }

        updateScoreUI();
    }

    function resetTileFlags() {
        tiles.forEach(t => {
            t.merged = false;
            t.toRemove = false;
        });
    }

    function move(direction) {
        if (isMoving || overlayGameOver.style.display === 'flex' || overlayRank.style.display === 'flex') return;
        isMoving = true;

        resetTileFlags();

        let moved = false;
        let newBoard = Array(size).fill(null).map(() => Array(size).fill(null));

        if (direction === 'left' || direction === 'right') {
            const isRight = direction === 'right';

            for (let r = 0; r < size; r++) {
                const cols = [];
                if (isRight) {
                    for (let c = size - 1; c >= 0; c--) {
                        if (board[r][c] !== null) cols.push(c);
                    }
                } else {
                    for (let c = 0; c < size; c++) {
                        if (board[r][c] !== null) cols.push(c);
                    }
                }

                let target = isRight ? size - 1 : 0;
                let i = 0;

                while (i < cols.length) {
                    const c = cols[i];
                    const idA = board[r][c];
                    const tileA = getTileById(idA);
                    const oldRowA = tileA.row;
                    const oldColA = tileA.col;

                    if (i + 1 < cols.length) {
                        const c2 = cols[i + 1];
                        const idB = board[r][c2];
                        const tileB = getTileById(idB);

                        if (tileA.value === tileB.value) {
                            moved = true;
                            tileA.value *= 2;
                            tileA.row = r;
                            tileA.col = target;
                            tileA.merged = true;
                            tileB.toRemove = true;
                            score += tileA.value;
                            newBoard[r][target] = tileA.id;
                            i += 2;
                        } else {
                            tileA.row = r;
                            tileA.col = target;
                            newBoard[r][target] = tileA.id;
                            i += 1;
                            if (oldRowA !== tileA.row || oldColA !== tileA.col) {
                                moved = true;
                            }
                        }
                    } else {
                        tileA.row = r;
                        tileA.col = target;
                        newBoard[r][target] = tileA.id;
                        i += 1;
                        if (oldRowA !== tileA.row || oldColA !== tileA.col) {
                            moved = true;
                        }
                    }

                    target += isRight ? -1 : 1;
                }
            }
        } else {
            const isDown = direction === 'down';

            for (let c = 0; c < size; c++) {
                const rows = [];
                if (isDown) {
                    for (let r = size - 1; r >= 0; r--) {
                        if (board[r][c] !== null) rows.push(r);
                    }
                } else {
                    for (let r = 0; r < size; r++) {
                        if (board[r][c] !== null) rows.push(r);
                    }
                }

                let target = isDown ? size - 1 : 0;
                let i = 0;

                while (i < rows.length) {
                    const r = rows[i];
                    const idA = board[r][c];
                    const tileA = getTileById(idA);
                    const oldRowA = tileA.row;
                    const oldColA = tileA.col;

                    if (i + 1 < rows.length) {
                        const r2 = rows[i + 1];
                        const idB = board[r2][c];
                        const tileB = getTileById(idB);

                        if (tileA.value === tileB.value) {
                            moved = true;

                            if (isDown) {
                                // å¾€ä¸‹ï¼šä¸Šé¢é‚£é¡†æ»‘ä¸‹ä¾†
                                tileB.value *= 2;
                                tileB.row = target;
                                tileB.col = c;
                                tileB.merged = true;
                                tileA.toRemove = true;
                                score += tileB.value;
                                newBoard[target][c] = tileB.id;
                            } else {
                                // å¾€ä¸Šï¼šä¸Šé¢é‚£é¡†å¾€ä¸Šåˆæˆ
                                tileA.value *= 2;
                                tileA.row = target;
                                tileA.col = c;
                                tileA.merged = true;
                                tileB.toRemove = true;
                                score += tileA.value;
                                newBoard[target][c] = tileA.id;
                            }

                            i += 2;
                        } else {
                            tileA.row = target;
                            tileA.col = c;
                            newBoard[target][c] = tileA.id;
                            i += 1;
                            if (oldRowA !== tileA.row || oldColA !== tileA.col) {
                                moved = true;
                            }
                        }
                    } else {
                        tileA.row = target;
                        tileA.col = c;
                        newBoard[target][c] = tileA.id;
                        i += 1;
                        if (oldRowA !== tileA.row || oldColA !== tileA.col) {
                            moved = true;
                        }
                    }

                    target += isDown ? -1 : 1;
                }
            }
        }

        tiles = tiles.filter(t => !t.toRemove);
        board = newBoard;

        if (moved) {
            addRandomTile();
            renderAll();
        }

        if (!hasAnyMoves()) {
            showGameOver();
        }

        setTimeout(() => {
            isMoving = false;
        }, 140);
    }

    // éµç›¤ï¼ˆç®­é ­ + WASDï¼‰
    document.addEventListener('keydown', (e) => {
        if (overlayGameOver.style.display === 'flex' || overlayRank.style.display === 'flex') return;
        const key = e.key.toLowerCase();
        if (key === 'arrowleft' || key === 'a')  move('left');
        if (key === 'arrowright' || key === 'd') move('right');
        if (key === 'arrowup' || key === 'w')    move('up');
        if (key === 'arrowdown' || key === 's')  move('down');
    });

    // æ‰‹æ©Ÿæ»‘å‹•
    let touchStartX = null;
    let touchStartY = null;

    document.addEventListener('touchstart', (e) => {
        if (overlayGameOver.style.display === 'flex' || overlayRank.style.display === 'flex') return;
        const t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
        if (overlayGameOver.style.display === 'flex' || overlayRank.style.display === 'flex') return;
        if (touchStartX === null || touchStartY === null) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        const threshold = 30;

        if (absX < threshold && absY < threshold) {
            touchStartX = touchStartY = null;
            return;
        }

        if (absX > absY) {
            if (dx > 0) move('right');
            else        move('left');
        } else {
            if (dy > 0) move('down');
            else        move('up');
        }

        touchStartX = touchStartY = null;
    }, { passive: true });

    // ä¸Šå‚³æˆç¸¾
    function uploadCurrentScore() {
        if (hasUploadedThisRun) {
            alert('æœ¬å±€æˆç¸¾å·²ç¶“ä¸Šå‚³éå›‰ï¼');
            return;
        }
        const list = loadScoresFromStorage();
        list.push({ score, time: new Date().toISOString() });
        list.sort((a, b) => b.score - a.score);
        saveScoresToStorage(list);
        hasUploadedThisRun = true;
        updateBestScoreFromStorage();
        alert('æˆç¸¾å·²ä¸Šå‚³ï¼');
    }

    btnUpload.addEventListener('click', () => {
        uploadCurrentScore();
    });

    btnPlayAgain.addEventListener('click', () => {
        if (!hasUploadedThisRun) {
            const wantUpload = confirm('ä½ å°šæœªä¸Šå‚³é€™ä¸€å±€çš„æˆç¸¾ï¼Œæ˜¯å¦è¦å…ˆä¸Šå‚³ï¼Ÿ');
            if (wantUpload) {
                uploadCurrentScore();
                return;
            }
        }
        init();
    });

    btnHomeOverlay.addEventListener('click', () => {
        overlayGameOver.style.display = 'none';
        // ä¹‹å¾Œé€™è£¡å¯ä»¥æ”¹æˆå¯¦éš›é¦–é é€£çµ
    });

    // é‡æ–°é–‹å§‹ï¼ˆåº•éƒ¨æŒ‰éˆ•ï¼Œä¸å¼·è¿«ä¸Šå‚³ï¼‰
    btnRestart.addEventListener('click', () => {
        init();
    });

    // æ’è¡Œæ¦œ
    function openRankOverlay() {
        const list = loadScoresFromStorage();
        rankList.innerHTML = '';
        if (list.length === 0) {
            rankEmpty.style.display = 'block';
        } else {
            rankEmpty.style.display = 'none';
            list.slice(0, 10).forEach((item, index) => {
                const li = document.createElement('li');
                const date = new Date(item.time);
                const dateStr = date.toLocaleString('zh-TW', { month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
                li.textContent = `ç¬¬ ${index + 1} åï¼š${item.score} åˆ†ï¼ˆ${dateStr}ï¼‰`;
                rankList.appendChild(li);
            });
        }
        overlayRank.style.display = 'flex';
    }

    btnRank.addEventListener('click', openRankOverlay);
    btnCloseRank.addEventListener('click', () => {
        overlayRank.style.display = 'none';
    });

    // éŸ³æ•ˆé–‹é—œï¼ˆç›®å‰åªæœ‰é¡¯ç¤ºç‹€æ…‹ï¼Œä¹‹å¾Œå¯æ¥å¯¦éš›éŸ³æ•ˆï¼‰
    function updateSoundButtonLabel() {
        btnSound.textContent = soundOn ? 'ğŸ”Š éŸ³æ•ˆï¼šé–‹' : 'ğŸ”ˆ éŸ³æ•ˆï¼šé—œ';
    }
    btnSound.addEventListener('click', () => {
        soundOn = !soundOn;
        updateSoundButtonLabel();
    });

    // åˆå§‹åŒ–
    buildGrid();
    updateBestScoreFromStorage();
    updateSoundButtonLabel();
    init();
</script>

</body>
</html>
